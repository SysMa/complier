/* Generated By:JJTree&JavaCC: Do not edit this line. XYZCompiler.java */
package com.lexAndParse;

import java.util.HashMap;
import java.util.Map;

public class XYZCompiler/*@bgen(jjtree)*/implements XYZCompilerTreeConstants, XYZCompilerConstants {/*@bgen(jjtree)*/
  protected JJTXYZCompilerState jjtree = new JJTXYZCompilerState();public static void main(String args [])
  {
    System.out.println("Reading from standard input...");
    System.out.print("Enter an expression like \u005c"1+(2+3)*var;\u005c" :");
    Map<String, Integer> tokenCountMap = new HashMap<String, Integer>();
    StringBuffer tokenStr = new StringBuffer("");
    XYZCompiler xyzc = new XYZCompiler(System.in);
    try
    {
      SimpleNode n = xyzc.program(tokenCountMap, tokenStr);
      n.dump("");
      System.out.println("Thank you.");
      System.out.println(tokenCountMap);
    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
  }

  final public SimpleNode program(Map<String, Integer> tokenCountMap,
                                   StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Integer weight = 0;
  Integer subWeight = 0;
    try {
      subWeight = mainClass(tokenCountMap, tokenStr);
    weight += subWeight;
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLASS:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        subWeight = classDecl(tokenCountMap, tokenStr);
      weight += subWeight;
      }
    tokenCountMap.put("$weight$", weight);
    {if (true) return jjtn000;}
      jj_consume_token(0);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Integer mainClass(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) MainClass */
  SimpleNode jjtn000 = new SimpleNode(JJTMAINCLASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Integer subWeight = 0;
  Integer temp;
    try {
      _class(tokenCountMap, tokenStr);
      id(tokenCountMap, tokenStr);
      jj_consume_token(LBRACE);
             tokenStr.append("LBRACE({)\u005cn");
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case INTEGER:
        case LONG:
        case ID:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        temp = varOrMethodDecl(tokenCountMap, tokenStr);
      subWeight += temp;
      }
      _static(tokenCountMap, tokenStr);
      _void(tokenCountMap, tokenStr);
      _main(tokenCountMap, tokenStr);
      jj_consume_token(LPAREN);
             tokenStr.append("LPAREN(() ");
      jj_consume_token(RPAREN);
             tokenStr.append("RPAREN()) ");
      jj_consume_token(LBRACE);
             tokenStr.append("LBRACE({)\u005cn");
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case BOOLEAN:
        case IF:
        case WHILE:
        case INTEGER:
        case LONG:
        case ID:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_3;
        }
        temp = statement(tokenCountMap, tokenStr);
      subWeight += temp;
      }
      jj_consume_token(RBRACE);
             tokenStr.append("RBRACE(})\u005cn");
      jj_consume_token(RBRACE);
             tokenStr.append("RBRACE(})\u005cn");
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return subWeight;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Integer classDecl(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) ClassDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTCLASSDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Integer subWeight = 0;
  Integer temp;
    try {
      _class(tokenCountMap, tokenStr);
      id(tokenCountMap, tokenStr);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        _extends(tokenCountMap, tokenStr);
        id(tokenCountMap, tokenStr);
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
             tokenStr.append("LBRACE({)\u005cn");
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case INTEGER:
        case LONG:
        case ID:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_4;
        }
        temp = varOrMethodDecl(tokenCountMap, tokenStr);
      subWeight += temp;
      }
      jj_consume_token(RBRACE);
             tokenStr.append("RBRACE(})\u005cn");
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return subWeight;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Integer varOrMethodDecl(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) VarOrMethodDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTVARORMETHODDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Integer subWeight = 0;
  Integer temp;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case INTEGER:
      case LONG:
        type(tokenCountMap, tokenStr);
        break;
      case ID:
        id(tokenCountMap, tokenStr);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      id(tokenCountMap, tokenStr);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
      case ASSIGN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
                    tokenStr.append("SEMICOLON(;)\u005cn");
          break;
        case ASSIGN:
          assign(tokenStr);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INTEGER_LITERAL:
          case LONG_LITERAL:
          case LPAREN:
          case NOT:
          case FALSE:
          case NEW:
          case THIS:
          case TRUE:
          case ID:
            exp(tokenCountMap, tokenStr);
            break;
          case LSQPAREN:
            jj_consume_token(LSQPAREN);
                     tokenStr.append("LSQPAREN([) ");
            expList(tokenCountMap, tokenStr);
            jj_consume_token(RSQPAREN);
                     tokenStr.append("RSQPAREN(]) ");
            break;
          default:
            jj_la1[6] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(SEMICOLON);
                      tokenStr.append("SEMICOLON(;)\u005cn");
          break;
        default:
          jj_la1[7] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return 1;}
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
                     tokenStr.append("LPAREN(() ");
        formalList(tokenCountMap, tokenStr);
        jj_consume_token(RPAREN);
                     tokenStr.append("RPAREN()) ");
        jj_consume_token(LBRACE);
                     tokenStr.append("LBRACE({)\u005cn");
        preDecl(tokenCountMap, tokenStr);
        postDecl(tokenCountMap, tokenStr);
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case BOOLEAN:
          case IF:
          case WHILE:
          case INTEGER:
          case LONG:
          case ID:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_5;
          }
          temp = statement(tokenCountMap, tokenStr);
                  subWeight += temp;
        }
        _return(tokenCountMap, tokenStr);
        exp(tokenCountMap, tokenStr);
                subWeight += 1;
        jj_consume_token(SEMICOLON);
                        tokenStr.append("SEMICOLON(;)\u005cn");
        jj_consume_token(RBRACE);
                     tokenStr.append("RBRACE(})\u005cn");
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return subWeight;}
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Integer mid_varDecl(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Mid_VarDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTMID_VARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      type(tokenCountMap, tokenStr);
      id(tokenCountMap, tokenStr);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
                  tokenStr.append("SEMICOLON(;)\u005cn");
        break;
      case ASSIGN:
        assign(tokenStr);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case LPAREN:
        case NOT:
        case FALSE:
        case NEW:
        case THIS:
        case TRUE:
        case ID:
          exp(tokenCountMap, tokenStr);
          break;
        case LSQPAREN:
          jj_consume_token(LSQPAREN);
                   tokenStr.append("LSQPAREN([) ");
          expList(tokenCountMap, tokenStr);
          jj_consume_token(RSQPAREN);
                   tokenStr.append("RSQPAREN(]) ");
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(SEMICOLON);
                    tokenStr.append("SEMICOLON(;)\u005cn");
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return 1;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void formalList(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) FormalList */
  SimpleNode jjtn000 = new SimpleNode(JJTFORMALLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case INTEGER:
      case LONG:
        type(tokenCountMap, tokenStr);
        break;
      case ID:
        id(tokenCountMap, tokenStr);
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      id(tokenCountMap, tokenStr);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_6;
        }
        jj_consume_token(COMMA);
             tokenStr.append("COMMA(,) ");
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case INTEGER:
        case LONG:
          type(tokenCountMap, tokenStr);
          break;
        case ID:
          id(tokenCountMap, tokenStr);
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        id(tokenCountMap, tokenStr);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void preDecl(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) PreDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTPREDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      pre(tokenCountMap, tokenStr);
      jj_consume_token(COLON);
                                         tokenStr.append("COLON(:) ");
      exp(tokenCountMap, tokenStr);
      jj_consume_token(SEMICOLON);
                                              jjtree.closeNodeScope(jjtn000, true);
                                              jjtc000 = false;
                                             tokenStr.append("SEMICOLON(;)\u005cn");
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void postDecl(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) PostDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTPOSTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      post(tokenCountMap, tokenStr);
      jj_consume_token(COLON);
                                          tokenStr.append("COLON(:) ");
      exp(tokenCountMap, tokenStr);
      jj_consume_token(SEMICOLON);
                                              jjtree.closeNodeScope(jjtn000, true);
                                              jjtc000 = false;
                                             tokenStr.append("SEMICOLON(;)\u005cn");
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void type(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        integer(tokenCountMap, tokenStr);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LSQPAREN:
          jj_consume_token(LSQPAREN);
                tokenStr.append("LSQPAREN([) ");
          jj_consume_token(RSQPAREN);
                tokenStr.append("RSQPAREN(]) ");
          break;
        default:
          jj_la1[15] = jj_gen;
          ;
        }
        break;
      case LONG:
        _long(tokenCountMap, tokenStr);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LSQPAREN:
          jj_consume_token(LSQPAREN);
                tokenStr.append("LSQPAREN([) ");
          jj_consume_token(RSQPAREN);
                tokenStr.append("RSQPAREN(]) ");
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        break;
      case BOOLEAN:
        _boolean(tokenCountMap, tokenStr);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public Integer statement(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Integer temp;
  Integer subWeight = 0;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case INTEGER:
      case LONG:
        subWeight = mid_varDecl(tokenCountMap, tokenStr);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return subWeight;}
        break;
      case LBRACE:
        jj_consume_token(LBRACE);
             tokenStr.append("LBRACE({) ");
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case BOOLEAN:
          case IF:
          case WHILE:
          case INTEGER:
          case LONG:
          case ID:
            ;
            break;
          default:
            jj_la1[18] = jj_gen;
            break label_7;
          }
          temp = statement(tokenCountMap, tokenStr);
      subWeight += temp;
        }
        jj_consume_token(RBRACE);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
             tokenStr.append("RBRACE(}) ");{if (true) return subWeight;}
        break;
      case IF:
        _if(tokenCountMap, tokenStr);
        jj_consume_token(LPAREN);
              tokenStr.append("LPAREN(() ");
        exp(tokenCountMap, tokenStr);
        jj_consume_token(RPAREN);
              tokenStr.append("RPAREN()) ");
        temp = statement(tokenCountMap, tokenStr);
    subWeight = temp;
        _else(tokenCountMap, tokenStr);
        temp = statement(tokenCountMap, tokenStr);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    subWeight += temp;
    subWeight = subWeight * 2;
    {if (true) return subWeight;}
        break;
      case WHILE:
        _while(tokenCountMap, tokenStr);
        jj_consume_token(LPAREN);
             tokenStr.append("LPAREN(() ");
        exp(tokenCountMap, tokenStr);
        jj_consume_token(RPAREN);
             tokenStr.append("RPAREN()) ");
        temp = statement(tokenCountMap, tokenStr);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    subWeight = temp * 4;
    {if (true) return subWeight;}
        break;
      case ID:
        id(tokenCountMap, tokenStr);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          id(tokenCountMap, tokenStr);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEMICOLON:
            jj_consume_token(SEMICOLON);
                      tokenStr.append("SEMICOLON(;)\u005cn");
            break;
          case ASSIGN:
            assign(tokenStr);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case INTEGER_LITERAL:
            case LONG_LITERAL:
            case LPAREN:
            case NOT:
            case FALSE:
            case NEW:
            case THIS:
            case TRUE:
            case ID:
              exp(tokenCountMap, tokenStr);
              break;
            case LSQPAREN:
              jj_consume_token(LSQPAREN);
                       tokenStr.append("LSQRAREN([) ");
              expList(tokenCountMap, tokenStr);
              jj_consume_token(RSQPAREN);
                       tokenStr.append("RSQPAREN(]) ");
              break;
            default:
              jj_la1[19] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            jj_consume_token(SEMICOLON);
                        tokenStr.append("SEMICOLON(;)\u005cn");
            break;
          default:
            jj_la1[20] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case LSQPAREN:
        case ASSIGN:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASSIGN:
            assign(tokenStr);
            exp(tokenCountMap, tokenStr);
            jj_consume_token(SEMICOLON);
            break;
          case LSQPAREN:
            jj_consume_token(LSQPAREN);
                   tokenStr.append("LSQPAREN([) ");
            exp(tokenCountMap, tokenStr);
            jj_consume_token(RSQPAREN);
                   tokenStr.append("RSQPAREN(]) ");
            assign(tokenStr);
            exp(tokenCountMap, tokenStr);
            jj_consume_token(SEMICOLON);
                    tokenStr.append("SEMICOLON(;)\u005cn");
            break;
          default:
            jj_la1[21] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return 1;}
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void exp(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Exp */
  SimpleNode jjtn000 = new SimpleNode(JJTEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEW:
        _new(tokenCountMap, tokenStr);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
        case LONG:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INTEGER:
            integer(tokenCountMap, tokenStr);
            break;
          case LONG:
            _long(tokenCountMap, tokenStr);
            break;
          default:
            jj_la1[24] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(LSQPAREN);
                   tokenStr.append("LSQPAREN([) ");
          exp(tokenCountMap, tokenStr);
          jj_consume_token(RSQPAREN);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                   tokenStr.append("RSQPAREN(]) ");
          break;
        case ID:
          id(tokenCountMap, tokenStr);
          jj_consume_token(LPAREN);
               tokenStr.append("LPAREN(() ");
          jj_consume_token(RPAREN);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
               tokenStr.append("RPAREN()) ");
          break;
        default:
          jj_la1[25] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case LPAREN:
      case FALSE:
      case THIS:
      case TRUE:
      case ID:
        unaryExp(tokenCountMap, tokenStr);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LSQPAREN:
        case DOT:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LSQPAREN:
            jj_consume_token(LSQPAREN);
                   tokenStr.append("LSQPAREN([) ");
            exp(tokenCountMap, tokenStr);
            jj_consume_token(RSQPAREN);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                   tokenStr.append("RSQPAREN(]) ");
            break;
          case DOT:
            dot(tokenStr);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LENGTH:
              length(tokenCountMap, tokenStr);
              break;
            case ID:
              id(tokenCountMap, tokenStr);
              jj_consume_token(LPAREN);
                   tokenStr.append("LPAREN(() ");
              expList(tokenCountMap, tokenStr);
              jj_consume_token(RPAREN);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                   tokenStr.append("RPAREN()) ");
              break;
            default:
              jj_la1[26] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[27] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[28] = jj_gen;
          lowLevelExp(tokenCountMap, tokenStr);
        }
        break;
      case NOT:
        not(tokenStr);
        exp(tokenCountMap, tokenStr);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void lowLevelExp(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) LowLevelExp */
  SimpleNode jjtn000 = new SimpleNode(JJTLOWLEVELEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      highLevelExp(tokenCountMap, tokenStr);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
        case AND:
        case OR:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_8;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          and(tokenStr);
          break;
        case OR:
          or(tokenStr);
          break;
        case PLUS:
          plus(tokenStr);
          break;
        case MINUS:
          minus(tokenStr);
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        unaryExp(tokenCountMap, tokenStr);
        highLevelExp(tokenCountMap, tokenStr);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void highLevelExp(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) HighLevelExp */
  SimpleNode jjtn000 = new SimpleNode(JJTHIGHLEVELEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LESSTHAN:
        case LARGERTHAN:
        case MUL:
        case DIVISION:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LESSTHAN:
          lessthan(tokenStr);
          break;
        case LARGERTHAN:
          largerthan(tokenStr);
          break;
        case MUL:
          multi(tokenStr);
          break;
        case DIVISION:
          division(tokenStr);
          break;
        default:
          jj_la1[33] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        unaryExp(tokenCountMap, tokenStr);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void unaryExp(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) UnaryExp */
  SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LONG_LITERAL:
        long_literal(tokenStr);
        break;
      case INTEGER_LITERAL:
        int_literal(tokenStr);
        break;
      case TRUE:
        _true(tokenCountMap, tokenStr);
        break;
      case FALSE:
        _false(tokenCountMap, tokenStr);
        break;
      case ID:
        id(tokenCountMap, tokenStr);
        break;
      case THIS:
        _this(tokenCountMap, tokenStr);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
             tokenStr.append("LPAREN(() ");
        exp(tokenCountMap, tokenStr);
        jj_consume_token(RPAREN);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
             tokenStr.append("RPAREN()) ");
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void expList(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) ExpList */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      exp(tokenCountMap, tokenStr);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[35] = jj_gen;
          break label_10;
        }
        jj_consume_token(COMMA);
    tokenStr.append("COMMA(,) ");
        exp(tokenCountMap, tokenStr);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void long_literal(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Long_Literal */
  SimpleNode jjtn000 = new SimpleNode(JJTLONG_LITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LONG_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("long_literal ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void int_literal(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Int_Literal */
  SimpleNode jjtn000 = new SimpleNode(JJTINT_LITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(INTEGER_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("int_literal ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void id(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) ID */
  SimpleNode jjtn000 = new SimpleNode(JJTID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(ID);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Identifiers: " + t.image);
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Identifiers: " + t.image, i);
    tokenStr.append("id ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void assign(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Assign */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ASSIGN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("ASSIGN(<=) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void pre(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Pre */
  SimpleNode jjtn000 = new SimpleNode(JJTPRE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(PRE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "pre");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "pre", i);
    tokenStr.append("PRE ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void post(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Post */
  SimpleNode jjtn000 = new SimpleNode(JJTPOST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(POST);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "post");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "post", i);
    tokenStr.append("POST ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void integer(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Integer */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(INTEGER);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "int");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "int", i);
    tokenStr.append("INT ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void not(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Not */
  SimpleNode jjtn000 = new SimpleNode(JJTNOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(NOT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("NOT(!) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void and(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) And */
  SimpleNode jjtn000 = new SimpleNode(JJTAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(AND);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("AND(&&) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void or(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Or */
  SimpleNode jjtn000 = new SimpleNode(JJTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OR);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("OR(||) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void plus(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Plus */
  SimpleNode jjtn000 = new SimpleNode(JJTPLUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(PLUS);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("PLUS(+) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void minus(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Minus */
  SimpleNode jjtn000 = new SimpleNode(JJTMINUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(MINUS);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("MINUS(-) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void multi(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Multi */
  SimpleNode jjtn000 = new SimpleNode(JJTMULTI);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(MUL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("MULTI(*) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void division(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Division */
  SimpleNode jjtn000 = new SimpleNode(JJTDIVISION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DIVISION);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("DIVISION(/) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void lessthan(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Lessthan */
  SimpleNode jjtn000 = new SimpleNode(JJTLESSTHAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LESSTHAN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("LESSTHAN(<) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void largerthan(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Largerthan */
  SimpleNode jjtn000 = new SimpleNode(JJTLARGERTHAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LARGERTHAN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("LARGERTHAN(>) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void dot(StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Dot */
  SimpleNode jjtn000 = new SimpleNode(JJTDOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DOT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    tokenStr.append("DOT(.) ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void length(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Length */
  SimpleNode jjtn000 = new SimpleNode(JJTLENGTH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LENGTH);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "length");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "length", i);
    tokenStr.append("LENGTH ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _main(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Main */
  SimpleNode jjtn000 = new SimpleNode(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(MAIN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "main");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "main", i);
    tokenStr.append("MAIN ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _long(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Long */
  SimpleNode jjtn000 = new SimpleNode(JJTLONG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LONG);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "long");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "long", i);
    tokenStr.append("LONG ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _boolean(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Boolean */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(BOOLEAN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "boolean");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "boolean", i);
    tokenStr.append("BOOLEAN ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _class(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Class */
  SimpleNode jjtn000 = new SimpleNode(JJTCLASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(CLASS);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "class");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "class", i);
    tokenStr.append("CLASS ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _static(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Static */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATIC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(STATIC);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "static");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "static", i);
    tokenStr.append("STATIC ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _void(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Void */
  SimpleNode jjtn000 = new SimpleNode(JJTVOID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(VOID);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "void");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "void", i);
    tokenStr.append("VOID ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _extends(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Extends */
  SimpleNode jjtn000 = new SimpleNode(JJTEXTENDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(EXTENDS);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "extends");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "extends", i);
    tokenStr.append("EXTENDS ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _return(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Return */
  SimpleNode jjtn000 = new SimpleNode(JJTRETURN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(RETURN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "return");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "return", i);
    tokenStr.append("RETURN ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _if(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) If */
  SimpleNode jjtn000 = new SimpleNode(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IF);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "if");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "if", i);
    tokenStr.append("IF ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _else(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) Else */
  SimpleNode jjtn000 = new SimpleNode(JJTELSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ELSE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "else");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "else", i);
    tokenStr.append("ELSE ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _while(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) While */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(WHILE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "while");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "while", i);
    tokenStr.append("WHILE ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _new(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) New */
  SimpleNode jjtn000 = new SimpleNode(JJTNEW);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(NEW);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "new");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "new", i);
    tokenStr.append("NEW ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _this(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) This */
  SimpleNode jjtn000 = new SimpleNode(JJTTHIS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(THIS);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "this");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "this", i);
    tokenStr.append("THIS ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _true(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) True */
  SimpleNode jjtn000 = new SimpleNode(JJTTRUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(TRUE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "true");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "true", i);
    tokenStr.append("TRUE ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void _false(Map<String, Integer> tokenCountMap, StringBuffer tokenStr) throws ParseException {
 /*@bgen(jjtree) False */
  SimpleNode jjtn000 = new SimpleNode(JJTFALSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(FALSE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Integer i = tokenCountMap.get("Keywords: " + "false");
    if (i == null)
    {
      i = 0;
    }
    i++;
    tokenCountMap.put("Keywords: " + "false", i);
    tokenStr.append("FALSE ");
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  /** Generated Token Manager. */
  public XYZCompilerTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[36];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x80000000,0x40000000,0x40004000,0x0,0x40000000,0x40000000,0x8001700,0x50000,0x40004000,0x50400,0x8001700,0x50000,0x40000000,0x10000000,0x40000000,0x1000,0x1000,0x40000000,0x40004000,0x8001700,0x50000,0x41000,0x41000,0x40004000,0x0,0x0,0x0,0x21000,0x21000,0x8000700,0x6600000,0x6600000,0x1980000,0x1980000,0x700,0x10000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x20060,0x20078,0x2,0x20060,0x20060,0x20c84,0x0,0x20078,0x0,0x20c84,0x0,0x20060,0x0,0x20060,0x0,0x0,0x60,0x20078,0x20c84,0x0,0x0,0x20000,0x20078,0x60,0x20060,0x28000,0x0,0x0,0x20c84,0x0,0x0,0x0,0x0,0x20c04,0x0,};
   }

  /** Constructor with InputStream. */
  public XYZCompiler(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public XYZCompiler(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new XYZCompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public XYZCompiler(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XYZCompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public XYZCompiler(XYZCompilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(XYZCompilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[53];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 36; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 53; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
